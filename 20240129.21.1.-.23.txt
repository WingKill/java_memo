20240129 21. 제네릭1 - 23장 컬렉션 프레임워크

면접에서는, 자바의 역사에 관련된 내용을 섞는 것이 유용한 편.
---
기존에서는 비슷한 코드 형식이라도 클래스명을 구분하여 지어야 하는 경우가 생김.
-> 모든 클래스의 부모가 되는 Object 를 활용하여 클래스를 만듦.
-> 해당 클래스는 컴파일러의 오류 발견 가능성을 낮춘다. 
	- 필요할 때 형변환을 직접 해줘야 한다.
	- 잘못된 입력값을 넣었는데도 컴파일 에러를 발생시키지 않는 경우도 있었다.
---
제네릭을 도입하여, 훨씬 더 안전하게 코드를 작성할 수 있게 됨.
	- 형변환이 필요없고, 다를 시 컴파일 에러 발생
---
타입 매개변수는 여러 개 가질 수 있다.
---
타입 매개변수는 타입 제한을 걸 수 있다.
---
제네릭 클래스에서, 타입 매개변수 간의 상속은 적용되지 않는다. 
---
타입 매개변수의 제한 : 상한 제한, 하한 제한
---
와일드 카드를 갖고 있는 메서드는 메서드 오버로딩이 안된다.
강제로 오버로딩이 될 수 있도록 매개변수 하나를 추가하는 방식으로 할 수는 있지만, 너무 번거롭다.
그래서 와일드 카드와 제네릭을 혼용하여 메서드 오버로딩이 되도록 할 수 있다.
---
컬렉션 프레임워크는 구현하는 것보다 활용하는 걸 더 자주 할 것.
---
컬렉션 프레임워크 
- 현업에선 이미 많은 컬렉션 프레임워크들이 구현되어 있는 상태이므로, 활용이 중요하다고.
-> Collection<E>는 Set<E>,List<E>, Queue<E>의 부모이다. 
-> 해당 구조를 띄기 때문에 컬렉션 프레임워크라고 표현하는 것.
	- Set<E>
	- List<E>
	- Queue<E>
	- Map<K,V> 
---
컬렉션 프레임워크
- 자료구조 및 알고리즘을 구현해놓은 일종의 라이브러리이다. 
- 제네릭 기반으로 구현되어 있다.
- 1.1버전부터 있었지만, 1.5버전에 제네릭이 나오면서 다시 코드를 갈아엎었다고 한다.
---
사용을 위해 특징만 이해하면 된다.
---
List<E> 인터페이스를 구현하는 컬렉션 클래스들의 공통 특성
- 인스턴스의 저장 순서 유지
- 동일 인스턴스의 중복 저장을 허용한다.

List<E>를 구현하는 대표적인 컬렉션 클래스 : ArrayList<E>, LinkedList<E>
---
컬렉션 프레임워크는 데이터(객체)를 좀 더 쉽게 관리하도록 도와준다.
---
CRUD
- 사용자 인터페이스가 갖추어야 할 기능(정보의 참조/검색/갱신)을 가리키는 용어로서도 사용됨.
- 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능을 묶어서 일컫는 말
- Create(생성), Read(읽기), Update(갱신), Delete(삭제)
---
- 직접 개발자가 구현하는 것보다, 기존에 만들어진 메서드를 활용하는 것이 난이도 및 시간 관리 측면에서 용이
---
ArrayList<E> vs. LinkedList<E> 
- 해외에선 신입에게 자주 묻는다고.
- 대학원에서도 묻는다고.
- 질문을 받을진 모르겠지만, 알아는 두자.
- 현업에선 활용하기에 따라 둘 중 하나 사용하면 그만..
---
ArrayList<E> : 배열 기반
---
- 배열의 내용을 추가하려면? 
- 새로운 배열을 생성하여 기존 배열의 내용을 옮긴 후 다시 추가하는 과정을 거쳐야 함.
- 삭제 또한 동일한 방식으로 진행. 
-> ArrayList<E>는 기존에 해당 과정을 진행하는 메서드를 이미 만들어놓음.
---
ArrayList<E>의 단점
 - 저장 공간을 늘리는 과정에서 시간이 비교적 많이 소요된다.
 - 인스턴스의 삭제 과정에서 많은 연산이 필요할 수 있다. 따라서 느릴 수 있다.
ArrayList<E>의 장점
 - 저장된 인스턴스의 참조가 빠르다.
---
LinkedList<E> : 리스트 기반
---
LinkedList는 LinkedList 데이터 타입인 변수를 가지고 있다.
해당 변수는, LinkedList의 공간을 늘리고 줄이는 데 활용한다.
---
LinkedList<E>의 단점
 - 저장된 인스턴스의 참조 과정이 배열에 비해 복잡하다. 따라서 느릴 수 있다.
LinkedList<E>의 장점
 - 저장 공간을 늘리는 과정이 간단하다.
 - 저장된 인스턴스의 삭제 과정이 단순하다.
---
데이터베이스할 때 가장 많이 사용하는 것들 중 하나.
---
for each 문(enhanced for문)은 자바 1.5버전 이후로 나왔다고 한다.
---
list들에 초기화하는 메서드가 있긴 하지만, 잘못될 수 있으니깐... 
--- 
의외로 꼼꼼하게 보는 사람은 예외 처리하는 걸 상당히 좋아한다고.
try catch를 잘 사용하도록 하자.
---
public interface Collection<E> extends Iterable<E>
---
버전이 낮은 경우에는 새로 짜야 하는 경우가 꽤 많아진다고.
---
List에 저장된 인스턴스에 순차적으로 접근하는 방법 
- for
	- 인덱스 값을 통해 접근
	- for each문을 통해 접근
- Iterator 인터페이스를 통해 접근
---
옛날에는 Iterator 구현을 많이 했었다고. 최근은 모름.
---
Iterator를 구현할 때 배열로 구현.
배열에는 배열을 컨트롤하는 인덱스가 반드시 존재한다.
---
커서(Cursor)는 반복자(Iterator)가 현재 가리키고 있는 위치를 나타내는 값
---
Java에서 Iterator 인터페이스는 JDK 1.2부터 지원
---
Iterator를 구현한 객체는, 한번 커서를 돌리면 원상복구할 수 없다. 다시 해당 과정을 진행하려면, 객체를 재생성하여 해당 과정을 진행해야 한다.
---
```
		Iterator<String> itr = list.iterator();
		while(itr.hasNext()) { // 리턴할 객체가 있는지 없는지 확인
			System.out.println(itr.next());
			// 커서가 가리키고 있는 객체를 리턴
		}
```
---
배열 기반으로 되어 있는 메서드를 구현하라는 문제가 대기업 코딩시험에서 나올 수 있다.
---
배열보다는 ArrayList<E>가 더 좋다. 
- 인스턴스 저장 및 삭제가 편리하다.
- 반복자 사용 가능.
그래서 현업에서도 배열보단 list 구현 함수를 자주 쓰는 것.
---
Iterator : 단방향 반복자. 배열 기반.
ListIterator : 양방향 반복자. 배열 기반.
---
List에 담긴 커서와 인덱스의 의미.
디버깅을 통해, 공부를 할 수 있다.
---
ListIterator의 add함수는 해당 커서에 객체를 추가하고, 나머지 담겨있는 객체들의 인덱스와 커서를 1칸씩 옮기게 된다.
