20240425 S_S_encryption/ transaction

---

- 암호화된 것을 알아야, 자기에게 들어온 패스워드를 비교를 함
```
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(customUserDetailsService)
			.passwordEncoder(passwordEncoder()); // 암호화 방식 
	}
```

---

기존에 있는 코드는 절대 바꾸지 않는다.
-> 차라리 새로 만들어라.

변경사항이 발생했을 때, 클래스 내에서 기존 코드를 수정하는 것보다는 
기존 코드를 복사한 신규 클래스를 만들어 해당 클래스를 수정하는 것이 좋다.
- 습관들이기가 참 힘든 것 같다.

---

암호화 모듈 및 CSRF
- 암호화 : 사용자가 입력한 데이터를 알아볼 수 없는 데이터로 변경하는 과정
	- 양방향  
	- 단방향


- Spring Security는 단방향 암호화 모듈을 채택
	- 같은 값을 넣으면 똑같은 값으로 암호화가 된다. -> 일치 여부 따질 때 이를 활용 가능
	- 복호화가 되지 않는다 -> 복호화가 가능한 경우에 발생하게 되는 해킹 위험성 배제

- CSRF
	- Cross-site request forgery
	- 사이트 간 위조 요청
	- 사용자가 로그인되어 있는 상태여야 함(관리자로 인증 및 권한이 부여된 사용자)
	-> 해커가 태그가 들어간 코드가 담긴 메일을 보냄.	
	-> 사용자가 메일을 열 때, 이미지 파일을 받아오기 위해 URL이 열림
	- 사례로, 2008년 옥션에서 발생한 개인정보 해킹 사건(1800만명 가량)이 있다.
	
- 모든 해커들의 최종 목적은 root 권한을 얻는 것

---

- CSRF 방어 방법
	- CAPTCHA 방식 활용 
		- 트위터에서 볼 수 있는, 다수의 이미지 중 특정 이미지들을 선택하여 인증하는 방식.
		-> 유저한테 한번 더 확인을 시키는 것	
		- AI가 나오면서 이미지를 돌리기 때문에 이것도 불안하다고...
	- CSRF 토큰 사용(Spring Security에서 지원)

---

Spring Security CSRF 토큰 사용법
	- POST, UPDATE, DELETE에서만 적용됨.(GET방식 미적용)
	-> CSRF를 막기 위해서 넣는 것
	- 요청 때마다 즉시 랜덤 토큰을 뿌려서, 이를 확인하는 방식
	-> 매번 value 값이 변하고,  hidden으로 포함되어 들어감.
	-> 공격자 입장에서는, 고정된 쿼리문만 전송하면 더 이상 명령이 작동되지 않음

- CSRF 토큰을 사용할 땐 해당 방식으로 페이지에 넣어줘야 한다.
-> 일일히 넣어줘야 한다.
```
<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />
```
-> 해당 input 태그를 넣지 않고 알아서 처리하게 만드려면 form이라는 태그 라이브러리를 추가하고 사용하면 된다.
```
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
```

- form 태그는 괜찮지만, ajax로 보낼 때 상당히 귀찮다고 한다.

---

Spring Security
- 보안 = 인증 + 권한 (로그인 + 리소스 접근 권한)
- 암호화 모듈 제공
- CSRF, XSS, 디도스 등의 공격을 방어

---

##  CSRF(Cross-site request forgery) 공격과 토큰
 스프링 시큐리티에서 POST 방식을 이용하는 경우 기본적으로 CSRF 토큰이라는 것을 이용하게 된다. 별도의 설정이 없다면 스프링 시큐리티가 적용된 사이트의 모든 POST 방식에는 CSRF 토큰이 사용되는데 '사이트간 위조 방지'를 목적으로 특정한 값의 토큰을 사용하는 방식이다.

CSRF 공격은 '사이트간 요청 위조'라고 번역될 수 있다. 서버에서 받아들이는 정보가 특별히 사전 조건을 검증하지 않는다는 단점을 이용하는 공격이다. 

예를 들어 A라는 사이트가 존재한다고 가정하고, A 사이트에는 특정 사용자의 등급을 변경하는 URI가 존재하고 파라미터가 필요하다는 것을 공격자가 알았을 때, 공격자는 A 사이트의 관리자(피해자)가 자주 방문하는 B 사이트에 <img> 태그나 <form> 태그를 이용해서 위의 URI를 추가한 게시물을 작성한다. A 사이트의 관리자(피해자)는 자신이 평상시 방문하던 B 사이트를 방문하게 되고 공격자가 작성한 게시물을 보게 된다. 이때 태그 등에 사용된 URI가 호출되고 서버에서 로그인한 관리자의 요청에 의해서 공격자는 admin 등급의 사용자로 변경된다.
A 사이트 관리자는 자신이 관리하던 A 사이트에 로그인이 되어 있는 상태라면 A 사이트의 서버 입장에서는 로그인한 사용자의 정상적인 요청으로 해석된다. 
CSRF 공격은 서버에서 받아들이는 요청을 해석하고 처리할 때 어떤 출처에서 호출이 징행되엇는지 따지지 않기 때문에 생기는 허점을 노리는 공격 방식이다.

CSRF는 현실적으로 하나의 사이트 내에서도 가능하다. 공격을 막기 위해서는 여러 방식이 존재한다. 
 1) CSRF 공격 자체가 사용자의 요청에 대한 출처를 검사하지 않아서 생기는 허점이기 때문에 사용자의 요청에 대한 출처를 의미하는 referer 헤더를 체크하거나 
 2) REST 방식에서 사용되는 PUT, DELETE와 같은 방식을 이용하는 것이 있다.

## CSRF 토큰
CSRF 토큰은 사용자가 임의로 변하는 특정한 토큰값을 서버에서 체크하는 방식이다. 서버에서 브라우저에 데이터를 전송할 때 CSRF 토큰을 같이 전송한다. 사용자가 POST 방식 등으로 특정한 작업을 할 때는 브라우저에서 전송된 CSRF 토큰의 값과 서버가 보관하고 있는 토큰의 값을 비교한다. 만일 CSRF 토큰 값이 다르다면 작업을 처리하지 않는 방식이다. 서버에서 생성하는 토큰은 일반적으로 난수를 생성해서 공격자가 패턴을 찾을 수 없도록 한다.

 아무튼 공격자 입장에서는 CSRF 공격을 하려면 변경되는 CSRF 토큰의 값을 알아야만 하기 때문에 고정된 내용의 태그 등을 이용할 수 없게 된다.

---

- 트랜잭션 
	- DB에 대한 개념
	- 어떤 일련의 작업(한번에 이루어져야 하는 작업 단위)
	- 모두 에러없이 끝나야 하며, 중간에 에러가 발생한다면 에러 발생 이전 시점까지 작업되었던 내용은 모두 원상복구되어야 함.
	-> 500 및 404 등의 에러 처리가 아니면, 에러 발생 시 DB로 하여금 원상복구하도록 DB에 요청하는 것
	- DB에서는 commit, rollback과 같은 원상복구하는 방법이 존재.
	- 대상 SQL 명령은 INSERT, UPDATE, DELETE가 해당됨

---

프레임워크에서도 rollback 시킬 수 있는 방법을 제공해줌.

- Spring에서 제공하는 트랜잭션 사용 방법
	- 1) Spring context 설정 파일에서 Transaction 선언
	- 2) Spring Transaction Annotation을 사용한 Transaction 선언
	- 3) Spring API를 사용하여 프로그램 소스 상에 Transaction 구현

	- 1), 2) : Spring AOP 사용 

---

@Transactional을 적용시킨 함수
- 소프트웨어적으로 함수에서 에러가 있으면, 롤백시키라는 의미를 담는 에너테이션
-> 함수 내 로직에 에러가 발생하는 경우, 해당 함수의 로직을 모두 rollback시킨다.

@Transactional을 적용시키지 않으면, 함수 내 에러가 발생되지 않는 시점까지는 데이터 삽입, 수정, 삭제가 발생할 수 있음.
- 이를 막기 위해, @Transactional를 적용시키는 것.

핵심 포인트 : @Transactional은 unchecked exception이 발생하면 롤백이 되지만, checked exception이 발생할 땐 롤백이 되지 않는다.
	- checked exception : 메서드에서 에러가 발생할 수 있음을 명시적으로 선언하고, 호출하는 쪽에서 해당 예외를 처리.
	- unchecked exception : 명시적인 예외 처리가 필요하지 않음.
	-> checked exception은 '개발자가 직접 에러 처리를 해야 하기 때문'에, @Transactional은 해당 exception에 대해서는 롤백처리를 하지 않도록 설정한 것.

그렇기 때문에, checked exception의 경우에는 @Transactional만 사용하면 안된다.
rollback이 되는 클래스를 지정해주는 작업이 필요하다.
```
@Transactional(rollbackFor = Exception.class)
```

---

26일은 controller test 관련 사항 및 통합 테스트, 인수 테스트 확인
29일 : Spring Legacy(서버에서 어느 순간 막았기 때문에, 해당 프로젝트가 아니라 따로 하게 될 것)
	- 면접 질문도 실제로 Spring Legacy 위주로 묻게 된다.

5월달부터는 선배 작품을 참조하며, 해야 하는 부분을 다 말해줄 것이다.

---
